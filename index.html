<!DOCTYPE html>
<title>ntrprty</title>

<style>
/* Light-weight global reset. */
*, *:before, *:after {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
  line-height: 1;
}

body {
  font-family: "Open Sans", sans-serif;
  color: #888;
  background: #eee;
  font-size: 17px;
}

a {
  color: #666;
}

code, pre, label, input, dd:before, dt:before {
  font-family: "Hasklug Nerd Font Mono", "Hasklug NF", "Hasklug Nerd Font", Hasklig, Monofur, monospace;
  -moz-tab-size: 4;
    -o-tab-size: 4;
       tab-size: 4;
  font-size: inherit;
  line-height: inherit;
}

#repl dt {
	display: block;
	position: relative;
	background: #222;
	padding: 10px 15px;
	cursor: pointer;
}

#repl dt:first-child {
	display: flex;
	padding-bottom: 5px;
	margin-bottom: 2px;
}

#repl dt:before {
	content: ">>> ";
	opacity: 0.5;
	display: inline-block;
	white-space: pre;
	vertical-align: middle;
}

#repl dd:before {
	display: inline-block;
	white-space: pre;
	content: "<<< ";
	opacity: 0.5;
}

#repl dt:after {
	position: absolute;
	right: 10px;
	top: 5px;
	font-size: inherit;
	line-height: 1.66;
}

#repl dt.error {
	background-color: #F00A;
	color: black;
}

#repl .error:after {
  content: "ðŸ›‘";
}

#repl dt.error + * {
	background-color: #faa;
	color: black;
}

#repl dt.error + *:before {
	content: '';
}

#repl label {
	flex: 0 1;
	padding: 10px 5px 10px 15px;
	min-width: 5em;
	text-align: right;
}

#repl input, #repl dd {
	flex: 1;
	background: transparent;
	padding: 10px 15px;
	color: inherit;
	border: none;
	border-bottom: 2px solid transparent;
	position: relative;
}

#repl input {
	padding: 0 0 5px;
}

#repl dt:first-child::before {
	padding-top: 3px;
}

#repl input:focus {
	outline: none;
	border: 0px solid ActiveBorder;
	border-bottom-width: 2px;
	color: #000;
}

#repl input::placeholder {
	color: rgba(127,127,127,0.5);
}


@media (prefers-color-scheme: dark) {
  body {
    color: #aaa;
    background: #111;
  }

  a {
    color: #999;
  }

  pre {
    color: #999;
    border-color: #333;
  }

  #repl input:focus {
    color: white;
  }

  #repl dt.error {
    background-color: #300;
    color: #ddd;
  }

  #repl dt.error {
    background-color: #400;
    color: #999;
  }

  #repl dt.error + * {
    background-color: #200;
    color: #ddd;
  }
}
</style>

<dl id="repl">
	<dt><input id="input" placeholder="(+ 2 4)" autofocus="true"></dt>
</dl>

<div id=replOut></div>

<script>
// based on lispy by Peter Norvig: http://norvig.com/lispy.html
// forked from https://gist.github.com/Enichan/4a9fa87aef6405e13e1c072baa117beb by Enichan
// blame neither for what was done here
// title based on https://www.folklore.org/StoryView.py?story=Hungarian.txt

// This is akin to assigning a handful of Python lambdas, which is heinousâ€¦ but these really are more mathematical functions...
const load = source => parse(tokenize(source)),
	tokenize = source => source.replaceAll("(", " ( ").replaceAll(")", " ) ").split(" ").filter(i => i),
	toLispString = (l, s) => [l].map(v => Array.isArray(v) ? "(" + v.map(join).join(" ") + ")" : v).join(" "),
	makeProc = (parms, body, env) => (() => interp(body, new Env(parms, arguments, env)))

function parse(tokens) {
	if ( !tokens.length ) throw new Error("Unexpected EOF")
	
	let token = tokens.shift()
	
	if ( token === "(" ) {
		let l = []  // Can *almost* use a comprehension here.
		while (tokens[0] !== ")") l.push(parse(tokens))
		tokens.shift()
		return l
	}
	else if (token === ")") throw new Error("Unexpected ')'")
	else return atom(token)
}

function atom(token) {
	let num = token * 1  // Similarly, can almost use an arrow function if not for this cast.
	return (num || num === 0) ? num : token
}

class Env {
	constructor(parms=[], args=[], outer) {
		parms.map((k, i) => this[k] = args[i])
		this.outer = outer
	}
	
	find(symbol) {
		if (typeof this[symbol] !== "undefined") return this
		if (this.outer) return this.outer.find(symbol)
		throw new Error(`Symbol ${symbol} undefined`)
	}
}

function makeEnv() {
	let env = new Env()
	
	for ( let property of Object.getOwnPropertyNames(Math) )
		if (typeof Math[property] === 'function') env[property] = Math[property]
	
	for ( let op of [["+"], ["-"], ["*"], ["/"], ["<"], ["<="], [">"], [">="], ["=", "==="]] )
		env[op[0]] = new Function("lhs", "rhs", `return lhs ${op[1] || op[0]} rhs;`)
	
	Object.assign(env, {
		append: (x, y, ...args) => x.concat(y).concat(...args),
		apply: (f, x) => f.apply(f, x),
		begin: (...args) => Array.isArray(args) ? args[args.length - 1] : undefined,
		car: (x) => x[0],
		cdr: (x) => x.slice(1),
		cons: (x, y) => [x].concat(y),
		"eq?": (x, y) => x === y,
		// "equal?" list contents equality D:
		length: (x) => x.length,
		list: (...args) => args,
		"list?": (x) => Array.isArray(x),
		map: (f, x) => x.map(f),
		not: (x) => x === false ? true : false,
		"null?": (x) => Array.isArray(x) && x.length == 0,
		"number?": (x) => typeof x === "number",
		"procedure?": (x) => typeof x === "function",
		reverse: (x) => x.reverse(),
		"symbol?": (x) => typeof x === "string",
	})
	
	return env
}

var g = makeEnv()

function interp(x, env) {
	var symbol, exp
	env = env || g
	
	if (typeof x === "string") return env.find(x)[x]  // symbol
	else if (!Array.isArray(x)) return x  // constant literal
	else switch ( x[0] ) {
		case "quote":  // (quote exp)
			return x[1]
		case "if":  // (if test conseq alt)
			let test = x[1], conseq = x[2], alt = x[3]
			exp = interp(test, env) ? conseq : alt
			return interp(exp, env)
		case "define":  // (define symbol exp)
			symbol = x[1], exp = x[2]
			env[symbol] = interp(exp, env)
			return
		case "set!":  // (set! symbol exp)
			symbol = x[1], exp = x[2]
			env.find(symbol)[symbol] = interp(exp, env)
			return
		case "lambda":  // (lambda (symbol...) body)
			let parms = x[1], body = x[2]
			return makeProc(parms, body, env)
		default:
			let proc = interp(x[0], env)
			let args = x.slice(1).map(exp => interp(exp, env))
			if (typeof proc !== "function") throw new Error("Expected function.")
			return proc.apply(proc, args)
	}
}

function tick(source, out) {
	let inputElement = document.createElement('dt'),
		inputCode = document.createElement('code'),
		outputElement = document.createElement('dd'),
		outputCode = document.createElement('code')
	
	inputCode.innerText = source
	inputElement.append(inputCode)
	inputElement.classList.add('working')
	input.parentElement.after(inputElement)
	
	outputElement.append(outputCode)
	
	
	let val
	
	try {
		val = interp(load(source))
	} catch (e) {
		outputCode.innerText = e.message
		inputElement.classList.add('error')
	}
	
	if (typeof val !== "undefined") {
		outputCode.innerText = toLispString(val)
	}
	
	inputElement.after(outputElement)
	inputElement.classList.remove('working')
}

repl.addEventListener('click', e => {  // Bound to the overall container for event bubbling.
	// Permit re-use of previously evaluated expressions.
	e = e || window.event
	let elem = e.srcElement || e.target
	
	if ( !elem.matches('dt:not(:first-child)') ) return
	input.value = elem.innerText
	input.focus()
}, false)

input.addEventListener('keydown', e => {
	e = e || window.event
	if ( e.keyCode != 13 ) return
	
	let elem = e.srcElement || e.target
	tick(elem.value, replOut)
	elem.value = ""
})
</script>

<html>
<head>
<title>Interpretoy</title>
</head>
<body>

<script>
// based on lispy by Peter Norvig: http://norvig.com/lispy.html

function load(source) {
    return parse(tokenize(source));
}

function tokenize(source) {
    return source.replaceAll("(", " ( ").replaceAll(")", " ) ").split(" ").filter(i => i);
}

function parse(tokens) {
    if (!tokens.length) {
        throw new Error("Unexpected EOF");
    }
    let token = tokens.shift();
    if (token === "(") {
        let l = [];
        while (tokens[0] !== ")") {
            l.push(parse(tokens));
        }
        tokens.shift();
        return l;
    }
    else if (token === ")") {
        throw new Error("Unexpected ')'");
    }
    else {
        return atom(token);
    }
}

function atom(token) {
    let num = token * 1;
    if (num) {
        return num;
    }
    return token;
}

function toLispString(l, s) {
    return [l].map(function join(v) { 
        return Array.isArray(v) ? "(" + v.map(join).join(" ") + ")" : v;
    }).join(" ");
}

function makeEnv() {
    var env = new Env();
    Object.getOwnPropertyNames(Math).forEach(property => {
        if(typeof Math[property] === 'function') {
            env[property] = Math[property];
        }
    });
    [ ["+", "Add"], ["-", "Sub"], ["*", "Mul"], ["/", "Div"], ["<", "Less"], ["<=", "LeEq"], [">", "Grea"], [">=", "GeEq"], [ "=", "Eq", "===" ]].forEach(op => {
        let opName = `op${op[1]}`;
        env[op[0]] = new Function("lhs", "rhs", `return lhs ${op[2] || op[0]} rhs;`);
    });
    Object.assign(env, {
        append: (x, y, ...args) => x.concat(y).concat(...args),
        apply: (f, x) => f.apply(f, x),
        begin: (...args) => Array.isArray(args) ? args[args.length - 1] : undefined,
        car: (x) => x[0],
        cdr: (x) => x.slice(1),
        cons: (x, y) => [x].concat(y),
        "eq?": (x, y) => x === y,
        //"equal?" list contents equality D:
        list: (...args) => args,
        "list?": (x) => Array.isArray(x),
        map: (f, x) => x.map(f),
        not: (x) => x === false ? true : false,
        "null?": (x) => Array.isArray(x) && x.length == 0,
        "number?": (x) => typeof x === "number",
        "procedure?": (x) => typeof x === "function",
        "symbol?": (x) => typeof x === "string",
    });
    return env;
};

class Env {
    constructor(parms, args, outer) {
        if (typeof parms === "undefined") parms = []
        if (typeof args === "undefined") args = []
        parms.map((k, i) => this[k] = args[i]);
        this.outer = outer;
    }
    
    find(symbol) {
        if (typeof this[symbol] !== "undefined") {
            return this;
        }
        if (this.outer) {
            return this.outer.find(symbol);
        }
        throw new Error(`Symbol ${symbol} undefined`);
    }
}

var g = makeEnv();

function makeProc(parms, body, env) {
    return function() {
        return interp(body, new Env(parms, arguments, env));
    };
}

function interp(x, env) {
    env = env || g;
    if (typeof x === "string") { // symbol
        return env.find(x)[x];
    }
    else if (!Array.isArray(x)) { // constant literal
        return x;
    }
    else if (x[0] === "quote") { // (quote exp)
        let exp = x[1];
        return exp;
    }
    else if (x[0] === "if") { // (if test conseq alt)
        let test = x[1], conseq = x[2], alt = x[3];
        let exp = interp(test, env) ? conseq : alt;
        return interp(exp, env);
    }
    else if (x[0] === "define") { // (define symbol exp)
        let symbol = x[1], exp = x[2];
        env[symbol] = interp(exp, env);
    }
    else if (x[0] === "set!") { // (set! symbol exp)
        let symbol = x[1], exp = x[2];
        env.find(symbol)[symbol] = interp(exp, env);
    }
    else if (x[0] === "lambda") { // (lambda (symbol...) body)
        let parms = x[1], body = x[2];
        return makeProc(parms, body, env);
    }
    else {
        let proc = interp(x[0], env);
        let args = x.slice(1).map(exp => interp(exp, env));
        if (typeof proc !== "function") {
            throw new Error("Expected function");
        }
        return proc.apply(proc, args);
    }
}

function repl(source, out) {
    out.innerHTML += "<br>";
    out.innerHTML += "> " + source;

    let val;
    try {
        val = interp(load(source));
    }
    catch (e) {
        val = "ERROR: " + e.message;
    }
    if (typeof val !== "undefined") {
        out.innerHTML += "<br>";
        out.innerHTML += toLispString(val);
    }
}

function replSubmit(e) {
    e = e || window.event;
    if (e.keyCode == 13) {
        let elem = e.srcElement || e.target;
        repl(elem.value, document.getElementById("replOut"));
        elem.value = "";
        elem.scrollIntoView();
    }
}

</script>

<div id="replOut">REPL:<br></div>
<br>
<input type="text" size="50" onkeydown="replSubmit()"/>  

</body>
</html>